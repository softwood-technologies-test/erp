<!DOCTYPE html>
<html lang="en">
  <head>
    {% load static %}
      <link rel="icon" href="{% static 'Logo 3x.png' %}">
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <script src="https://cdn.tailwindcss.com"></script>
      <script>
        tailwind.config = {
          darkMode: 'media',
        };
      </script>
      
      <script src="https://code.jquery.com/jquery-3.7.1.js"></script>
      <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
      <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>

      <link href="https://cdn.jsdelivr.net/npm/daisyui@latest/dist/full.css" rel="stylesheet" type="text/css" />

      <script src="https://cdn.jsdelivr.net/npm/flowbite@3.1.2/dist/flowbite.min.js"></script>

      <link rel="stylesheet" href="{% static 'style.css' %}">
      
      <link href="https://cdn.jsdelivr.net/npm/tom-select@2.4.3/dist/css/tom-select.css" rel="stylesheet">
      <script src="https://cdn.jsdelivr.net/npm/tom-select@2.4.3/dist/js/tom-select.complete.min.js"></script>
      
      <title>
          {% block title %} Fashion OS {% endblock %}
      </title>
      
      <!--Icons from Google fonts-->
      <div>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
        <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
        <style>
          .material-symbols-outlined {
            font-variation-settings:
            'FILL' 0,
            'wght' 400,
            'GRAD' 0,
            'opsz' 20;
            font-size: 14px;
            cursor: pointer;
          }
        </style>
      </div>
  </head>
  
  <body class="font-sans"> 
    <!--Navigation Bar-->

    <div class="{{theme.navigationBar}}">
      <div class="navbar-start">
        <ul class="menu menu-horizontal px-1">
          <li><a href="{% url 'productivity' %}">Dashboard</a></li>
          <li class="dropdown dropdown-hover">
            <label tabindex="0" class="cursor-pointer">Presets</label>
            <ul tabindex="0" class="dropdown-content menu p-2 shadow bg-base-100 rounded-box w-52">
              <li><a href="{% url 'styleBulletins' %}">Style Bulletin</a></li>
              <li><a href="{% url 'operations' %}">Operations</a></li>
              <li><a href="{% url 'machines' %}">Machines</a></li>
              <li><a href="{% url 'workers' %}">Workers</a></li>
            </ul>
          </li>
          <li class="dropdown dropdown-hover">
            <label tabindex="0" class="cursor-pointer">Cutting</label>
            <ul tabindex="0" class="dropdown-content menu p-2 shadow bg-base-100 rounded-box w-52">
              <li><a href="{% url 'coreSheets' %}">Core Sheet</a></li>
            </ul>
          </li>
        </ul>
      </div>
      <div class="navbar-end">
        <ul class="menu menu-horizontal px-1 items-center">
          <li>
            <span>Logged in as {{user.first_name}}</span>
          </li>
          <li>
            <a href="/logout">Logout</a>
          </li>
          <li><a href="/">Go to Main</a></li>
        </ul>
      </div>
    </div>
        
    <!--Message Box-->
    <div id="message-container"></div>
    
    <!--Main Body-->
    <div class="{{theme.pageBody}}">
        {% block content %} {% endblock %}
    </div>

    <!--Loading Animiation-->
    <div style="position: fixed;" id="loadingIcon" hidden>
      <span class="{{theme.loadingIcon}}">autorenew</span>
    </div>

    <!--Simple drop down-->
    <div id="dropdown" class="fixed inset-0 z-50 hidden overflow-y-auto" aria-labelledby="modalLabel" aria-hidden="true">
      <div class="flex items-center justify-center min-h-screen px-4 pt-4 pb-20 text-center sm:block sm:p-0">
        <div class="fixed inset-0 transition-opacity" aria-hidden="true">
          <div class="absolute inset-0 bg-gray-500 opacity-75"></div>
        </div>
        <span class="hidden sm:inline-block sm:align-middle sm:h-screen" aria-hidden="true">&#8203;</span>
        <div class="relative inline-block overflow-hidden text-left align-bottom transition-all transform bg-white rounded-lg shadow-xl sm:my-8 sm:align-middle sm:max-w-lg sm:w-full">
          <div class="bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
            <div class="sm:flex sm:items-start">
              <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left">
                <h3 class="text-lg font-medium leading-6 text-gray-900" id="modalLabel">
                  Select an Option
                </h3>
              </div>
            </div>
            <div class="mt-2">
              <div class="mt-1">
                <select id="id_selectDropDown" class="block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"></select>
              </div>
            </div>
          </div>
          <div class="px-4 py-3 bg-gray-50 sm:px-6 sm:flex sm:flex-row-reverse">
            <button type="button" id="okButton" class="inline-flex justify-center w-full px-4 py-2 text-base font-medium text-gray-700 bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:mt-0 sm:ml-3 sm:w-auto">
              OK
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>    //To add the options for selects
      async function appendOptions (elementId, options, selected=null, removePrevious=true) {
          try {
            const element = document.getElementById(elementId);    
            
            if (removePrevious) {
              element.innerHTML = ''; 
            }
            
            const fragment = document.createDocumentFragment();

            options.forEach(optionData => {
              const option = document.createElement('option');
              option.text = optionData.text;
              option.value = optionData.value;
              if (optionData.value == selected) {
                  option.selected = true;
              }
              fragment.appendChild(option);
            });
    
            element.appendChild(fragment);
          } catch (error) {
            showMessage(`An Error occured: `+error);
          }
      }
    </script>

    <script>    //To show message to a user
      function showMessage(message, timeOut = 3, baseClass = '{{theme.errorBox}}') {
        //Get the container element
        const messageContainer = document.getElementById('message-container');

        // Create a new alert element
        const messageElement = document.createElement('div');
        //Set the correct bootstap class
        messageElement.classList.add(...baseClass.split(' '));
        messageElement.setAttribute('role', 'alert');
        
        //Add a the message and close button to the message.
        messageElement.innerHTML = `
          <span class="{{theme.messageBoxBody}}">${message}</span>
          <span class="{{theme.messageBoxClose}}">
            <span class="material-icons cursor-pointer">close</span>
          </span>`;

        //Add the message element to the container
        messageContainer.appendChild(messageElement);

        //close the message automatically after given number of seconds
        setTimeout(() => {
          messageElement.classList.replace('opacity-100','opacity-0');
          setTimeout(()=> {
              messageElement.remove();
          }, 300);
        }, timeOut * 1000);
      }
    </script>

    <script>  //To show/hide loading icon to user
      function showLoadingIcon(top=100, left=10, zIndex=9999) {
        const loadingIcon = document.getElementById('loadingIcon');

        loadingIcon.style.top = `${top}px`;
        loadingIcon.style.left = `${left}px`;
        loadingIcon.style.zIndex = zIndex;

        loadingIcon.removeAttribute('hidden');
      }

      function hideLoadingIcon() {
        const loadingIcon = document.getElementById('loadingIcon');

        loadingIcon.setAttribute('hidden','');
      }
    </script>

    <script>  //To show options dialogue box
      function showDropDown(options, onOkFunction, selected=null, searchBox=false) {
        const dialogBox = document.getElementById('dropdown');
        const dropdown = document.getElementById('id_selectDropDown');
        const okButton = document.getElementById('okButton');

        dropdown.innerHTML = '';

        for (const option of options) {
          const newOption = document.createElement('option');
          newOption.text = option.text;
          newOption.value = option.value;

          if (newOption.value === selected) {
            newOption.selected = true;
          } else {
            newOption.selected = false;
          }
          dropdown.appendChild(newOption);
        }

        okButton.onclick = onOkFunction;

        if (searchBox) {
          if ($(dropdown).hasClass("chosenSelect")) { // Check if Chosen is already initialized
            $(dropdown).trigger("chosen:updated"); // If so, just update
          } else {
              $(dropdown).chosen({
                  search_contains: true,
                  width: "100%"
              }).addClass("chosenSelect"); //Add a class to check if it has been initalized
          }
        }

        //convert the table to a bootstrap modal and show it to user.
        dialogBox.classList.remove('hidden');
        dialogBox.classList.add('flex');
      }
    </script>

    <script>  //To add or remove rows from tables 
      async function addRow (source) {
        //Remove the search box from elements
        removeSearchBox();
        
        const rowToCopy = source.parentElement.parentElement;
        const tableData = rowToCopy.parentElement     //Fetch the table body
        
        const copy = rowToCopy.cloneNode(true);     //Create a copy of the row

        // Clear written text that the copy got from source row
        for (const child of copy.children) {
          const inputs = child.querySelectorAll('input');
          inputs.forEach(input => {
            input.value = '';
          });

          const selects = child.querySelectorAll('select');
          selects.forEach(select => {
            select.selectedIndex = -1;
          });
        }
        
        //Insert the row after the clicked row
        tableData.insertBefore(copy, rowToCopy.nextSibling);
        
        //Change the serial numbers of the button for future usage
        const rows = tableData.children;
        for (let i=0;i<rows.length;i++) {
            rows[i].setAttribute("row",i);
        }
        
        addSearchBox();

        //Reset the sequence in any column named Sequence
        const sequences = tableData.querySelectorAll('[name*="Sequence"]')
        let previousSequence = 0;
        for (const sequence of sequences) {
            sequence.value = previousSequence+1;
            previousSequence = parseInt(sequence.value);
        }
      }

      async function removeRow (source, minRows = 0 ) {
        const tableData = source.parentElement.parentElement.parentElement;     //Fetch the table body   
        
        //Don't delete the row if it is the only one
        if (tableData.children.length < (minRows+3)) {
            alert("This is the last row. You cannot delete it!");
            return ;
        }

        const rowToRemove = source.parentElement.parentElement;    //Fetch the row out of the table
        const rowNum = parseInt(rowToRemove.getAttribute('row'));

        let dataFlag = false;               //Flag to check if there is data in the row

        const inputs = rowToRemove.querySelectorAll ("input");      //All the columns with inputs
        const selects = rowToRemove.querySelectorAll ("select");    //All the columns with selection options
        const combined = [...inputs, ...selects];                 //Combined inputs and selects

        for (const element of combined) {
            const deletable = element.parentElement.getAttribute("deletable") === "true";
            if (element.value && !deletable) {  
                dataFlag = true;                            //Set flag true if there is data in an element
                break;    
            }
        }
        
        if (dataFlag) {                 //Give warining if the dataflag is true.
            const removeFlag = confirm("There is data here. Are you sure you want to remove it?");
            if (!removeFlag) {          //User doesn't select OK.
                return ;
            }
        }

        rowToRemove.remove();           //Remove the row

        //Reset the serial in the buttons below the deleted row
        let rows = tableData.children;
        for (let i=rowNum;i<rows.length;i++) {
            rows[i].setAttribute("row",i);
        }

        //Reset the sequence in any column named Sequence
        const sequences = tableData.querySelectorAll('[name*="Sequence"]')
        let previousSequence = 0;
        for (const sequence of sequences) {
            sequence.value = previousSequence+1;
            previousSequence = parseInt(sequence.value);
        }
      }
    </script>

    <script>  //To add or remove search box
      function removeSearchBox() {
        //The keyword that is common in all search boxes
        const keyword = "chosen";
        //Get elements that contain the key word.
        const searchBoxNodes = document.querySelectorAll(`[${keyword}*='true']`);

        //Remove the search box from 
        for (const node of searchBoxNodes) {
            //Get the id of the seletion element
            const selectId = node.children[0].id;
            
            //Get the id of the selection box associated with selection element. It'll always be selectid_keyword
            const boxId = selectId+"_"+keyword;
    
            //Remove the selection box and destroy the script associated with it.
            document.getElementById(boxId).remove();
            $("#"+selectId).chosen("destroy"); 
        }
      }
      
      async function addSearchBox() {
        //The keyword that is common in all search boxes
        const keyword = "tom_select";
        //Get elements that contain the key word.
        const searchBoxNodes = document.querySelectorAll(`[${keyword}*='true']`);

        //Add search box to all nodes
        for (const node of searchBoxNodes) {
          //Get the row number of the element
          const row = node.parentElement.getAttribute("row")
          //Get the drop down inside the element
          const dropdown = node.children[0];
          
          //Get the id of the drop down. To make it unique, we preset it in the format column_row.
          let id = dropdown.getAttribute("id");
          
          //Get the position of the last _ in the id.
          const trimAfter = id.lastIndexOf("_");

          //If _ exists and isn't at start of id, get the part after _.
          if (trimAfter > 2) {
            id = id.substring(0, trimAfter);
          }
          
          //Set the id to new row number and set it on the dropdown
          id = `${id}_${row}`;
          dropdown.setAttribute('id', id);

          const selectSettings = {
            create: false,
            maxOptions: 50,
          };

          new TomSelect(`#${id}`,selectSettings);
        }
      }
    </script>

    <script> //To handle warning for unsaved data
      //The if is in response to a bug, where it wouldn't define unsavedDataFlag while replacing html
      if (typeof unsavedDataFlag === 'undefined') {
        let unsavedDataFlag = false;
      }

      //Show warning to user if there is unsaved data.
      window.addEventListener('beforeunload', (event) => {
        if (unsavedDataFlag) {
          event.preventDefault(); // For some older browsers
          event.returnValue = ''; // For chrome or firefox
          return ''; // for Safari
        }
      });
    </script>

    <script> //This function shows searchbox for a select element
      async function showSearchBox(source, url, nextFunction=null) {
        const rect = source.getBoundingClientRect();

        source.style.display = 'none';

        const originalOptions = Array.from(source.options).map(option => ({
          value: option.value,
          text: option.text,
        }));
        const originalValue = source.value;

        const searchContainer = document.createElement('div');
        searchContainer.classList.add('bg-base-100', 'rounded-box', 'shadow', 'w-full', 'mt-2', 'dark:bg-gray-900', 'dark:text-white');
        searchContainer.style.zIndex = '10';
        
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Type Here';
        searchInput.style.marginTop = '0.5rem';
        searchInput.classList.add(...'{{theme.textInput}}'.split(' '));
        searchContainer.appendChild(searchInput);

        const listContainer = document.createElement('ul');
        listContainer.classList.add('menu');
        searchContainer.appendChild(listContainer);

        async function fetchOptons(searchTerm = '') {
          try{
            showLoadingIcon();
            let response;

            if (searchTerm === '') {
              response = await fetch(`${url}?search=${originalValue}`);
            } else {
              response = await fetch(`${url}?search=${searchTerm}`);
            }

            if (!response.ok) {
                console.error(`HTTP error! status: ${response.status}`);
                listContainer.innerHTML = '<li class="disabled"><a>Error loading data</a></li>';
                hideLoadingIcon();
                return;
            }

            const data = await response.json();
            listContainer.innerHTML = ''; // Clear previous options from search container
            source.innerHTML = ''; // Clear previous options from original dropdown

            if (data && data.length > 0) {
              for (const option of data) {
                const listItem = document.createElement('li');
                const button = document.createElement('button');
                button.classList.add('w-full', 'text-left', 'hover:bg-base-200', 'dark:hover:bg-gray-800', 'focus:outline-none');
                button.textContent = option.text;
                button.value = option.value;
                button.type = 'button';

                const newOption = document.createElement('option');
                newOption.value = option.value;
                newOption.text = option.text;
                source.appendChild(newOption);

                listItem.appendChild(button);
                listContainer.appendChild(listItem);
                
                button.onclick = function () {
                  source.value = this.value;
                  source.style.display = '';
                  searchContainer.remove();
                  document.removeEventListener('click', handleClickOutside);

                  if (nextFunction) {
                    nextFunction(source);
                  }
                };
              }
            } else {
              const listItem = document.createElement('li');
              listItem.classList.add('disabled');
              listItem.textContent = 'No matching options';
              listContainer.appendChild(listItem);
            }
            hideLoadingIcon();
          } catch (error) {
            console.error(`Error fetching Options: ${error}`);
            listContainer.innerHTML = '<li class="disabled"><a>Error loading data</a></li>';
            return;
          }
        }

        await fetchOptons();

        let timeoutId;
        searchInput.addEventListener('input', async function() {
          const searchTerm = searchInput.value.trim();

          // Debounce the input to avoid excessive backend calls
          clearTimeout(timeoutId);

          timeoutId = setTimeout(async () => {
              await fetchOptons(searchTerm);
          }, 300);
        });

        searchContainer.appendChild(listContainer);

        searchContainer.style.left = `${rect.left}px`;
        searchContainer.style.top = `${rect.bottom}px`;
        searchContainer.style.width = `${rect.width}px`;
        
        source.parentNode.appendChild(searchContainer);
        
        //Bug: This doesn't work correctly.
        //document.body.appendChild(searchContainer);
        searchInput.focus();

        function handleClickOutside(clickEvent) {
          if (!searchContainer.contains(clickEvent.target) && clickEvent.target !== source) {
            closeSearchBox();
          }
        }

        function handleEscapeKey(keyEvent) {
          if (keyEvent.key === 'Escape') {
            closeSearchBox();
          }
        }

        function closeSearchBox() {
          searchContainer.remove();
          source.style.display = '';
          source.innerHTML = '';

          for (const option of originalOptions) {
            const newOption = document.createElement('option');
            newOption.value = option.value;
            newOption.text = option.text;
            source.appendChild(newOption);
          }
          source.value = originalValue;

          document.removeEventListener('click', handleClickOutside);
        }
        document.addEventListener('click', handleClickOutside);
        searchInput.addEventListener('keydown', handleEscapeKey);
      }
    </script>

  </body>
</html>